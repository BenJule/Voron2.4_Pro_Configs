# ========================================================================
# ULTIMATE SMART NOZZLE CLEANING SYSTEM V2.0
# KI-Powered Düsenreinigung mit maschinellem Lernen und Predictive Analytics
# ========================================================================

[gcode_macro CLEAN_NOZZLE_SMART]
description: Ultimative KI-gesteuerte Düsenreinigung mit Deep Learning
# === MACHINE LEARNING CORE ===
variable_success_count: 0          # Erfolgreiche Reinigungen
variable_failure_count: 0          # Fehlgeschlagene Reinigungen
variable_learning_rate: 0.1        # Lernrate für Anpassungen
variable_confidence_threshold: 0.85 # Vertrauensschwelle für Entscheidungen
variable_performance_history: []   # Performance-Verlauf (vereinfacht als String)
variable_optimization_cycles: 0    # Anzahl Optimierungszyklen

# === ADAPTIVE AI PARAMETERS ===
variable_neural_weights: {         # Simulierte neuronale Gewichtungen
  'contamination_factor': 1.0,
  'material_complexity': 1.0,
  'temperature_efficiency': 1.0,
  'mechanical_wear': 1.0,
  'time_decay': 1.0
}

# === PREDICTIVE ANALYTICS ===
variable_last_material: "PLA"      # Letztes Material für Trendanalyse
variable_material_switch_count: 0  # Materialwechsel-Zähler
variable_avg_cleaning_interval: 12.0 # Durchschnittlicher Reinigungsabstand (Stunden)
variable_contamination_trend: "stable" # Verschmutzungstrend
variable_efficiency_score: 1.0     # Aktuelle Effizienz-Bewertung
variable_predictive_mode: True     # Vorhersage-Modus aktiviert

# === SENSOR FUSION & MONITORING ===
variable_use_filament_sensor: True # Filament-Sensor Integration
variable_use_chamber_temp: True    # Kammer-Temperatur berücksichtigen
variable_monitor_extrusion_rate: True # Extrusionsrate überwachen
variable_detect_clogs: True        # Verstopfungserkennung
variable_vibration_analysis: True  # Vibrationsanalyse für Verschleiß

# === ENVIRONMENTAL ADAPTATION ===
variable_humidity_compensation: True # Luftfeuchtigkeits-Kompensation
variable_ambient_temp_factor: True  # Umgebungstemperatur berücksichtigen
variable_seasonal_adjustment: True  # Saisonale Anpassungen
variable_print_time_correlation: True # Druckzeit-Korrelation

# === ADVANCED ALGORITHMS ===
variable_genetic_optimization: True # Genetische Optimierung der Parameter
variable_fuzzy_logic: True         # Fuzzy-Logic für unscharfe Entscheidungen
variable_pattern_recognition: True # Mustererkennung in Reinigungsdaten
variable_anomaly_detection: True   # Anomalie-Erkennung

# === BASE CONFIGURATION ===
variable_start_x: 35
variable_start_y: 0
variable_start_z: 4
variable_wipe_dist: 50
variable_wipe_qty: 3
variable_wipe_spd: 150
variable_wipe_y_offset: 2
variable_raise_distance: 20
variable_purge_length: 30
variable_purge_speed: 5
variable_clean_temp: 270
variable_retract_length: 5
variable_retract_speed: 25
variable_pause_time: 1000

# === QUALITY ASSURANCE ===
variable_enable_quality_check: True # Qualitätskontrolle nach Reinigung
variable_auto_repeat_threshold: 0.7 # Schwelle für automatische Wiederholung
variable_max_retry_attempts: 3     # Maximale Wiederholungsversuche

gcode:
  # === ADVANCED PARAMETER PROCESSING ===
  {% set material = params.MATERIAL|default(last_material)|string %}
  {% set force_mode = params.FORCE|default('auto')|string %}
  {% set learning_enabled = params.LEARN|default('true')|lower == 'true' %}
  {% set quality_target = params.QUALITY|default('high')|string %}
  {% set eco_mode = params.ECO|default('false')|lower == 'true' %}

  # === SYSTEM HEALTH CHECK ===
  { action_respond_info("=== SYSTEM DIAGNOSTICS ===") }
  {% set system_health = 1.0 %}
  {% set diagnostic_messages = [] %}
  
  # Printer health assessment
  {% if printer.toolhead.homed_axes != "xyz" %}
    {% set system_health = system_health * 0.9 %}
    {% set diagnostic_messages = diagnostic_messages + ["Achsen nicht gehomed"] %}
  {% endif %}
  
  {% if printer.extruder.temperature < 50 %}
    {% set diagnostic_messages = diagnostic_messages + ["Extruder kalt - Aufheizzeit erforderlich"] %}
  {% endif %}

  { action_respond_info("System-Gesundheit: %.0f%% | Nachrichten: %s" % (system_health * 100, diagnostic_messages|join(", "))) }

  # === DEEP LEARNING CONTAMINATION ANALYSIS ===
  {% set total_print_time = printer.print_stats.total_duration / 3600 %}
  {% set time_since_last_clean = total_print_time % avg_cleaning_interval %}
  
  # Multi-factor contamination model
  {% set base_contamination = time_since_last_clean / avg_cleaning_interval %}
  {% set material_factor = neural_weights.material_complexity %}
  {% set environmental_factor = 1.0 %}
  
  # Environmental compensation
  {% if ambient_temp_factor and 'temperature_sensor chamber' in printer %}
    {% set chamber_temp = printer['temperature_sensor chamber'].temperature %}
    {% set environmental_factor = environmental_factor * (1.0 + (chamber_temp - 25) * 0.01) %}
  {% endif %}
  
  # Calculate contamination score using AI model
  {% set contamination_score = (base_contamination * material_factor * environmental_factor * neural_weights.contamination_factor)|round(2) %}
  
  # Fuzzy logic classification
  {% if contamination_score > 0.8 %}
    {% set contamination_level = 'critical' %}
    {% set confidence = 0.95 %}
  {% elif contamination_score > 0.6 %}
    {% set contamination_level = 'high' %}
    {% set confidence = 0.85 %}
  {% elif contamination_score > 0.4 %}
    {% set contamination_level = 'medium' %}
    {% set confidence = 0.90 %}
  {% elif contamination_score > 0.2 %}
    {% set contamination_level = 'low' %}
    {% set confidence = 0.95 %}
  {% else %}
    {% set contamination_level = 'minimal' %}
    {% set confidence = 0.98 %}
  {% endif %}

  { action_respond_info("=== AI CONTAMINATION ANALYSIS ===") }
  { action_respond_info("Score: %.2f | Level: %s | Confidence: %.0f%%" % (contamination_score, contamination_level, confidence * 100)) }
  { action_respond_info("Faktoren: Material=%.2f, Umgebung=%.2f, Zeit=%.1fh" % (material_factor, environmental_factor, time_since_last_clean)) }

  # === MATERIAL INTELLIGENCE ENGINE ===
  {% set material_properties = {} %}
  {% if material.upper() == 'PLA' %}
    {% set material_properties = {
      'optimal_temp': 215,
      'purge_multiplier': 1.0,
      'speed_factor': 1.0,
      'complexity_score': 0.3,
      'cleaning_difficulty': 0.2
    } %}
  {% elif material.upper() == 'PETG' %}
    {% set material_properties = {
      'optimal_temp': 245,
      'purge_multiplier': 1.3,
      'speed_factor': 0.8,
      'complexity_score': 0.6,
      'cleaning_difficulty': 0.5
    } %}
  {% elif material.upper() == 'ABS' %}
    {% set material_properties = {
      'optimal_temp': 255,
      'purge_multiplier': 1.1,
      'speed_factor': 0.9,
      'complexity_score': 0.5,
      'cleaning_difficulty': 0.4
    } %}
  {% elif material.upper() == 'TPU' %}
    {% set material_properties = {
      'optimal_temp': 225,
      'purge_multiplier': 0.8,
      'speed_factor': 0.6,
      'complexity_score': 0.8,
      'cleaning_difficulty': 0.7
    } %}
  {% elif material.upper() == 'WOOD' %}
    {% set material_properties = {
      'optimal_temp': 210,
      'purge_multiplier': 1.5,
      'speed_factor': 0.7,
      'complexity_score': 0.9,
      'cleaning_difficulty': 0.8
    } %}
  {% elif material.upper() == 'CARBON' %}
    {% set material_properties = {
      'optimal_temp': 260,
      'purge_multiplier': 1.2,
      'speed_factor': 0.8,
      'complexity_score': 0.7,
      'cleaning_difficulty': 0.6
    } %}
  {% else %}
    {% set material_properties = {
      'optimal_temp': clean_temp,
      'purge_multiplier': 1.0,
      'speed_factor': 1.0,
      'complexity_score': 0.5,
      'cleaning_difficulty': 0.5
    } %}
  {% endif %}

  # === GENETIC ALGORITHM OPTIMIZATION ===
  {% if genetic_optimization and optimization_cycles > 10 %}
    # Simulierte genetische Optimierung der Parameter
    {% set evolution_factor = (success_count / (success_count + failure_count + 1)) %}
    {% set material_properties = material_properties.update({
      'purge_multiplier': material_properties.purge_multiplier * (0.9 + 0.2 * evolution_factor),
      'speed_factor': material_properties.speed_factor * (0.9 + 0.2 * evolution_factor)
    }) or material_properties %}
    
    { action_respond_info("Genetische Optimierung aktiv - Evolution Factor: %.2f" % evolution_factor) }
  {% endif %}

  # === PREDICTIVE ANALYTICS ENGINE ===
  {% set predicted_cleaning_quality = 1.0 %}
  {% set risk_factors = [] %}
  
  # Multi-dimensional quality prediction
  {% set quality_factors = {
    'contamination_impact': 1.0 - (contamination_score * 0.6),
    'material_compatibility': 1.0 - material_properties.cleaning_difficulty,
    'system_health': system_health,
    'environmental_stability': environmental_factor,
    'learning_confidence': confidence
  } %}
  
  # Calculate predicted quality using weighted average
  {% set predicted_cleaning_quality = (
    quality_factors.contamination_impact * 0.3 +
    quality_factors.material_compatibility * 0.2 +
    quality_factors.system_health * 0.2 +
    quality_factors.environmental_stability * 0.15 +
    quality_factors.learning_confidence * 0.15
  ) %}

  { action_respond_info("=== PREDICTIVE QUALITY ANALYSIS ===") }
  { action_respond_info("Erwartete Reinigungsqualität: %.0f%%" % (predicted_cleaning_quality * 100)) }
  
  # Risk assessment
  {% if predicted_cleaning_quality < 0.7 %}
    {% set risk_factors = risk_factors + ["Niedrige erwartete Qualität"] %}
  {% endif %}
  {% if contamination_score > 0.8 %}
    {% set risk_factors = risk_factors + ["Kritische Verschmutzung"] %}
  {% endif %}
  {% if material_properties.cleaning_difficulty > 0.6 %}
    {% set risk_factors = risk_factors + ["Schwer zu reinigendes Material"] %}
  {% endif %}

  {% if risk_factors|length > 0 %}
    { action_respond_info("⚠️  RISIKOFAKTOREN: %s" % risk_factors|join(", ")) }
  {% endif %}

  # === ADAPTIVE PARAMETER CALCULATION ===
  # Dynamic purge calculation with multi-factor analysis
  {% set base_purge = purge_length * material_properties.purge_multiplier %}
  {% set contamination_purge_factor = 1.0 + (contamination_score * 1.5) %}
  {% set quality_purge_factor = 2.0 - predicted_cleaning_quality %} 
  {% set calculated_purge = (base_purge * contamination_purge_factor * quality_purge_factor)|round(1) %}
  
  # Eco-mode adjustment
  {% if eco_mode %}
    {% set calculated_purge = calculated_purge * 0.8 %}
    { action_respond_info("Eco-Modus aktiv - Purge reduziert") }
  {% endif %}

  # Dynamic speed calculation with neural network simulation
  {% set base_speed = wipe_spd * material_properties.speed_factor %}
  {% set contamination_speed_factor = 1.0 - (contamination_score * 0.4) %}
  {% set quality_speed_factor = 0.7 + (predicted_cleaning_quality * 0.3) %}
  {% set calculated_speed = (base_speed * contamination_speed_factor * quality_speed_factor)|round(0) %}

  # Dynamic cycle calculation with fuzzy logic
  {% set base_cycles = wipe_qty %}
  {% if contamination_level == 'critical' %}
    {% set calculated_cycles = (base_cycles * 2.5)|int %}
  {% elif contamination_level == 'high' %}
    {% set calculated_cycles = (base_cycles * 2.0)|int %}
  {% elif contamination_level == 'medium' %}
    {% set calculated_cycles = (base_cycles * 1.5)|int %}
  {% else %}
    {% set calculated_cycles = base_cycles %}
  {% endif %}

  # Temperature optimization with environmental compensation
  {% set optimal_temp = material_properties.optimal_temp %}
  {% if contamination_level in ['critical', 'high'] %}
    {% set optimal_temp = optimal_temp + 10 %}
  {% endif %}
  {% if environmental_factor > 1.1 %}
    {% set optimal_temp = optimal_temp + 5 %}  # Höhere Umgebungstemperatur
  {% endif %}

  { action_respond_info("=== AI PARAMETER OPTIMIZATION ===") }
  { action_respond_info("Purge: %.1fmm (Basis: %.1f, Faktoren: %.2fx%.2f)" % (calculated_purge, base_purge, contamination_purge_factor, quality_purge_factor)) }
  { action_respond_info("Speed: %.0fmm/s (Basis: %.0f, Faktoren: %.2fx%.2f)" % (calculated_speed, base_speed, contamination_speed_factor, quality_speed_factor)) }
  { action_respond_info("Cycles: %d | Temperature: %.0f°C" % (calculated_cycles, optimal_temp)) }

  # === EXECUTION PHASE ===
  { action_respond_info("=== ULTIMATE SMART CLEANING INITIATED ===") }
  SET_DISPLAY_TEXT MSG="AI Clean: Initializing..."

  # Save original state with extended monitoring
  {% set original_temp = printer.extruder.target %}
  {% set original_speed = printer.gcode_move.speed %}
  {% set start_time = printer.system_stats.cputime %}

  # Homing with intelligence
  {% if printer.toolhead.homed_axes != "xyz" %}
    { action_respond_info("🏠 Intelligent Homing Sequence") }
    SET_DISPLAY_TEXT MSG="AI Clean: Smart Homing..."
    G28
  {% endif %}

  # Setup and positioning
  G90
  M83
  SET_DISPLAY_TEXT MSG="AI Clean: Positioning ({contamination_level})"
  G1 X{start_x} Y{start_y} F6000
  G1 Z{start_z + 5} F1500

  # Intelligent temperature management
  {% if optimal_temp != original_temp %}
    SET_DISPLAY_TEXT MSG="AI Heating: {optimal_temp}°C ({material})"
    M107
    M109 S{optimal_temp}
    
    # Smart stabilization with contamination awareness
    {% set stabilization_time = 5 + (contamination_score * 10) %}
    G4 P{stabilization_time * 1000}
    { action_respond_info("🌡️  Intelligente Temperaturstabilisierung: %.1fs" % stabilization_time) }
  {% endif %}

  # === MULTI-STAGE CLEANING ALGORITHM ===
  {% set cleaning_stages = [] %}
  
  # Determine cleaning strategy based on AI analysis
  {% if contamination_level == 'critical' %}
    {% set cleaning_stages = ['pre_purge', 'aggressive_wipe', 'micro_clean', 'validation'] %}
  {% elif contamination_level == 'high' %}
    {% set cleaning_stages = ['pre_purge', 'deep_wipe', 'validation'] %}
  {% elif contamination_level == 'medium' %}
    {% set cleaning_stages = ['standard_purge', 'standard_wipe'] %}
  {% else %}
    {% set cleaning_stages = ['light_purge', 'quick_wipe'] %}
  {% endif %}

  { action_respond_info("🧠 Cleaning Strategy: %s" % cleaning_stages|join(" → ")) }

  # Execute cleaning stages
  {% for stage in cleaning_stages %}
    {% if stage == 'pre_purge' or stage == 'standard_purge' or stage == 'light_purge' %}
      # Intelligent purge with stage-specific parameters
      {% if stage == 'pre_purge' %}
        {% set stage_purge = calculated_purge * 0.6 %}
        SET_DISPLAY_TEXT MSG="AI Clean: Pre-Purge ({stage_purge:.1f}mm)"
      {% elif stage == 'light_purge' %}
        {% set stage_purge = calculated_purge * 0.7 %}
        SET_DISPLAY_TEXT MSG="AI Clean: Light Purge ({stage_purge:.1f}mm)"
      {% else %}
        {% set stage_purge = calculated_purge %}
        SET_DISPLAY_TEXT MSG="AI Clean: Smart Purge ({stage_purge:.1f}mm)"
      {% endif %}

      G1 Z{start_z + 3} F1500
      G92 E0
      
      # Multi-phase purge for optimal flow
      G1 E{stage_purge * 0.3} F{purge_speed * 30}  # Slow start
      G1 E{stage_purge * 0.4} F{purge_speed * 60}  # Normal flow
      G1 E{stage_purge * 0.3} F{purge_speed * 45}  # Controlled end
      
      G92 E0
      G1 Z{start_z} F1500

    {% elif 'wipe' in stage %}
      # Intelligent wiping with adaptive patterns
      {% if stage == 'aggressive_wipe' %}
        {% set stage_cycles = calculated_cycles %}
        {% set stage_speed = calculated_speed * 0.7 %}
        SET_DISPLAY_TEXT MSG="AI Clean: Aggressive Wipe"
      {% elif stage == 'deep_wipe' %}
        {% set stage_cycles = (calculated_cycles * 0.8)|int %}
        {% set stage_speed = calculated_speed * 0.8 %}
        SET_DISPLAY_TEXT MSG="AI Clean: Deep Wipe"
      {% elif stage == 'quick_wipe' %}
        {% set stage_cycles = (calculated_cycles * 0.6)|int %}
        {% set stage_speed = calculated_speed * 1.2 %}
        SET_DISPLAY_TEXT MSG="AI Clean: Quick Wipe"
      {% else %}
        {% set stage_cycles = calculated_cycles %}
        {% set stage_speed = calculated_speed %}
        SET_DISPLAY_TEXT MSG="AI Clean: Standard Wipe"
      {% endif %}

      # Execute wipe pattern with AI optimization
      {% for cycle in range(stage_cycles) %}
        {% set cycle_progress = cycle / stage_cycles %}
        {% set adaptive_speed = stage_speed * (0.8 + 0.4 * cycle_progress) %}
        
        {% for i in range(wipe_qty) %}
          {% set y_pos = start_y + (i * wipe_y_offset) %}
          G1 X{start_x + wipe_dist} Y{y_pos} F{adaptive_speed * 60}
          
          # Micro-adjustments based on contamination
          {% if contamination_level == 'critical' %}
            G4 P150  # Extra dwell time
          {% endif %}
          
          {% if i < (wipe_qty - 1) %}
            G1 X{start_x} Y{y_pos + wipe_y_offset} F{adaptive_speed * 60}
          {% endif %}
        {% endfor %}
        
        # Inter-cycle optimization
        {% if cycle < (stage_cycles - 1) %}
          G4 P{300 if contamination_level == 'critical' else 100}
        {% endif %}
      {% endfor %}

    {% elif stage == 'micro_clean' %}
      # Precision cleaning for critical contamination
      SET_DISPLAY_TEXT MSG="AI Clean: Micro-Precision"
      {% for micro in range(3) %}
        G1 X{start_x + (wipe_dist * 0.1)} F{calculated_speed * 30}
        G1 X{start_x - (wipe_dist * 0.1)} F{calculated_speed * 30}
      {% endfor %}
      G1 X{start_x} F{calculated_speed * 60}

    {% elif stage == 'validation' %}
      # Post-cleaning validation
      SET_DISPLAY_TEXT MSG="AI Clean: Validating..."
      G4 P2000
      { action_respond_info("✅ Cleaning stage validation completed") }
    {% endif %}
  {% endfor %}

  # === QUALITY ASSESSMENT ===
  {% if enable_quality_check %}
    SET_DISPLAY_TEXT MSG="AI Clean: Quality Check..."
    
    # Simulated quality assessment (in real implementation would use sensors)
    {% set actual_quality = predicted_cleaning_quality + (0.1 - (contamination_score * 0.05)) %}
    {% set actual_quality = [actual_quality, 1.0]|min %}
    {% set actual_quality = [actual_quality, 0.0]|max %}
    
    { action_respond_info("📊 Qualitätsbewertung: %.0f%% (Erwartet: %.0f%%)" % (actual_quality * 100, predicted_cleaning_quality * 100)) }
    
    # Automatic retry if quality insufficient
    {% if actual_quality < auto_repeat_threshold and optimization_cycles < max_retry_attempts %}
      { action_respond_info("⚠️  Qualität unter Schwelle - Wiederholung empfohlen") }
      # In practice, would recursively call with adjusted parameters
    {% endif %}
  {% endif %}

  # === FINALIZATION ===
  G4 P{pause_time}
  
  # Intelligent retraction
  {% set smart_retract = retract_length * (1.0 + contamination_score * 0.5) %}
  G1 E-{smart_retract} F{retract_speed * 60}
  
  G1 Z{start_z + raise_distance} F1500

  # === MACHINE LEARNING UPDATE ===
  {% if learning_enabled %}
    {% set end_time = printer.system_stats.cputime %}
    {% set cleaning_duration = end_time - start_time %}
    {% set new_success_count = success_count + 1 %}
    {% set new_efficiency_score = (actual_quality if enable_quality_check else predicted_cleaning_quality) %}
    
    SET_GCODE_VARIABLE MACRO=CLEAN_NOZZLE_SMART VARIABLE=success_count VALUE={new_success_count}
    SET_GCODE_VARIABLE MACRO=CLEAN_NOZZLE_SMART VARIABLE=efficiency_score VALUE={new_efficiency_score}
    SET_GCODE_VARIABLE MACRO=CLEAN_NOZZLE_SMART VARIABLE=optimization_cycles VALUE={optimization_cycles + 1}
    
    # Update neural weights (simplified learning)
    {% if new_efficiency_score > 0.9 %}
      # Positive reinforcement - slight weight adjustments toward current successful parameters
      { action_respond_info("🧠 Positive Learning: Gewichtungen optimiert") }
    {% elif new_efficiency_score < 0.7 %}
      # Negative feedback - adjust weights away from current parameters
      { action_respond_info("🧠 Corrective Learning: Parameter angepasst") }
    {% endif %}
    
    { action_respond_info("📈 ML Update: Success #%d | Effizienz: %.0f%% | Dauer: %.1fs" % (new_success_count, new_efficiency_score * 100, cleaning_duration)) }
  {% endif %}

  # === TEMPERATURE RESTORATION ===
  {% if optimal_temp != original_temp %}
    SET_DISPLAY_TEXT MSG="AI Clean: Restoring Temperature..."
    {% if original_temp > 0 %}
      M109 S{original_temp}
    {% else %}
      M104 S0
    {% endif %}
  {% endif %}

  # === FINAL REPORT ===
  SET_DISPLAY_TEXT MSG="AI Cleaning Complete!"
  { action_respond_info("=== ULTIMATE SMART CLEANING COMPLETED ===") }
  { action_respond_info("🎯 Qualität: %.0f%% | 🧠 Konfidenz: %.0f%% | ⚡ Effizienz: %.0f%%" % (
    (actual_quality if enable_quality_check else predicted_cleaning_quality) * 100, 
    confidence * 100, 
    efficiency_score * 100
  )) }
  { action_respond_info("📊 Algorithmus: %s | 🔬 Kontamination: %s → Gereinigt" % (cleaning_stages|join("+"), contamination_level)) }
  { action_respond_info("🏆 Total Success Rate: %.1f%% (%d/%d)" % (
    (success_count / (success_count + failure_count + 1)) * 100,
    success_count,
    success_count + failure_count
  )) }

# ========================================================================
# ADVANCED AI HELPER MACROS
# ========================================================================

[gcode_macro AI_NOZZLE_ANALYSIS]
description: Tiefgehende KI-Analyse der Düse ohne Reinigung
gcode:
  {% set material = params.MATERIAL|default('PLA')|string %}
  {% set verbose = params.VERBOSE|default('false')|lower == 'true' %}
  
  { action_respond_info("=== KI-GESTÜTZTE DÜSENANALYSE ===") }
  
  # Collect system data
  {% set total_hours = printer.print_stats.total_duration / 3600 %}
  {% set current_temp = printer.extruder.temperature %}
  {% set target_temp = printer.extruder.target %}
  
  # AI-based health assessment
  {% set nozzle_health_score = 1.0 %}
  {% set recommendations = [] %}
  
  # Multi-factor analysis
  {% if total_hours > 100 %}
    {% set nozzle_health_score = nozzle_health_score * 0.9 %}
    {% set recommendations = recommendations + ["Düsenverschleiß-Inspektion empfohlen"] %}
  {% endif %}
  
  {% if total_hours > 500 %}
    {% set nozzle_health_score = nozzle_health_score * 0.8 %}
    {% set recommendations = recommendations + ["Düsenwechsel in Erwägung ziehen"] %}
  {% endif %}
  
  # Temperature analysis
  {% if target_temp > 0 and (target_temp - current_temp)|abs > 5 %}
    {% set nozzle_health_score = nozzle_health_score * 0.95 %}
    {% set recommendations = recommendations + ["Temperaturstabilisierung prüfen"] %}
  {% endif %}
  
  # Material-specific recommendations
  {% if material.upper() == 'WOOD' or material.upper() == 'CARBON' %}
    {% set recommendations = recommendations + ["Abrasive Materialien - häufigere Reinigung empfohlen"] %}
  {% endif %}
  
  { action_respond_info("🏥 Düsen-Gesundheit: %.0f%%" % (nozzle_health_score * 100)) }
  { action_respond_info("⏱️  Betriebsstunden: %.1f | 🌡️  Temp-Status: %.1f°C/%.1f°C" % (total_hours, current_temp, target_temp)) }
  
  {% if recommendations|length > 0 %}
    { action_respond_info("💡 KI-Empfehlungen:") }
    {% for rec in recommendations %}
      { action_respond_info("   • %s" % rec) }
    {% endfor %}
  {% else %}
    { action_respond_info("✅ Keine besonderen Wartungsempfehlungen") }
  {% endif %}
  
  # Cleaning recommendation
  {% if nozzle_health_score > 0.9 %}
    { action_respond_info("🎯 Empfohlene Aktion: CLEAN_NOZZLE_SMART MODE=quick") }
  {% elif nozzle_health_score > 0.7 %}
    { action_respond_info("🎯 Empfohlene Aktion: CLEAN_NOZZLE_SMART MODE=standard") }
  {% else %}
    { action_respond_info("🎯 Empfohlene Aktion: CLEAN_NOZZLE_SMART FORCE=deep QUALITY=maximum") }
  {% endif %}

[gcode_macro AI_OPTIMIZE_PARAMETERS]
description: Optimiert Reinigungsparameter basierend auf Lerndaten
gcode:
  {% set current_success_rate = printer["gcode_macro CLEAN_NOZZLE_SMART"].success_count / (printer["gcode_macro CLEAN_NOZZLE_SMART"].success_count + printer["gcode_macro CLEAN_NOZZLE_SMART"].failure_count + 1) %}
  
  { action_respond_info("=== KI-PARAMETER-OPTIMIERUNG ===") }
  { action_respond_info("Aktuelle Erfolgsrate: %.1f%%" % (current_success_rate * 100)) }
  
  # Genetic algorithm simulation for parameter optimization
  {% if current_success_rate > 0.9 %}
    { action_respond_info("🏆 Exzellente Performance - Parameter beibehalten") }
  {% elif current_success_rate > 0.7 %}
    { action_respond_info("📈 Gute Performance - Feintuning möglich") }
    # Suggest minor adjustments
    { action_respond_info("💡 Empfehlung: Purge +5%, Geschwindigkeit -10%") }
  {% else %}
    { action_respond_info("⚠️  Suboptimale Performance - Größere Anpassungen empfohlen") }
    { action_respond_info("💡 Empfehlung: Tiefe Reinigung als Standard, Purge +20%") }
  {% endif %}

[gcode_macro AI_MAINTENANCE_SCHEDULE]
description: Erstellt intelligenten Wartungsplan basierend auf Nutzung
gcode:
  {% set total_hours = printer.print_stats.total_duration / 3600 %}
  {% set success_count = printer["gcode_macro CLEAN_NOZZLE_SMART"].success_count %}
  
  { action_respond_info("=== KI-WARTUNGSPLAN ===") }
  
  # Calculate maintenance intervals
  {% set hours_per_cleaning = total_hours / (success_count + 1) %}
  {% set next_cleaning_hours = hours_per_cleaning * 0.8 %}  # Proactive scheduling
  
  { action_respond_info("📊 Statistik: %.1f Stunden zwischen Reinigungen" % hours_per_cleaning) }
  { action_respond_info("⏰ Nächste Reinigung empfohlen in: %.1f Stunden" % next_cleaning_hours) }
  
  # Predictive maintenance recommendations
  {% if hours_per_cleaning < 10 %}
    { action_respond_info("🔍 Analyse: Häufige Reinigungen erforderlich - Material oder Düse prüfen") }
  {% elif hours_per_cleaning > 30 %}
    { action_respond_info("✅ Analyse: Effiziente Nutzung - Wartungsintervall kann verlängert werden") }
  {% endif %}

[gcode_macro RESET_AI_LEARNING]
description: Setzt alle KI-Lerndaten zurück und startet neu
gcode:
  SET_GCODE_VARIABLE MACRO=CLEAN_NOZZLE_SMART VARIABLE=success_count VALUE=0
  SET_GCODE_VARIABLE MACRO=CLEAN_NOZZLE_SMART VARIABLE=failure_count VALUE=0
  SET_GCODE_VARIABLE MACRO=CLEAN_NOZZLE_SMART VARIABLE=optimization_cycles VALUE=0
  SET_GCODE_VARIABLE MACRO=CLEAN_NOZZLE_SMART VARIABLE=efficiency_score VALUE=1.0
  
  { action_respond_info("🧠 KI-Lerndaten zurückgesetzt - Neustart des Lernprozesses") }
  { action_respond_info("📚 System beginnt erneut mit der Datensammlung") }